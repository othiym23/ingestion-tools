#!/usr/bin/env ruby
script_path = __FILE__
script_path = File.readlink(script_path) if File.symlink?(script_path)

$: << File.join(File.dirname(script_path), '../lib')

require 'path_utils'
require 'dao/album_dao'
require 'adaptor/euterpe_dashboard_factory'
require 'yaml'

ARCHIVE_BASE = '/data/music/mp3'
PENDING_BASE = '/data/music/holding/pending'

STDOUT.sync = true
source_directory = File.expand_path(PENDING_BASE)
raise IOError.new("Path #{source_directory} does not exist!") unless File.exists?(source_directory)

at_exit { puts "\nSeeya!" }

def narrow_albums(albums, search_term)
  if [] == albums
    if search_term && '' != search_term.strip
      AlbumDao.find_generously(search_term)
    end
  else
    albums.select do |album|
      album_name = "#{album.artist_name}: #{album.name}"
    
      puts "Matched #{search_term} as album artist name #{album.artist_name} on #{album_name}" if album.artist_name.match(/#{search_term}/i)
      puts "Matched #{search_term} as album name #{album.name} on #{album_name}" if album.name.match(/#{search_term}/i)
    
      album.artist_name.match(/#{search_term}/i) ||
      album.name.match(/#{search_term}/i) ||
      album.discs.compact.detect do |disc|
        disc.tracks.detect do |track|
          puts "Matched #{search_term} as track artist name #{track.artist_name} on #{album_name}" if track.artist_name.match(/#{search_term}/i)
          puts "Matched #{search_term} as track name #{track.name} on #{album_name}" if track.name.match(/#{search_term}/i)
    
          track.artist_name.match(/#{search_term}/i) ||
          track.name.match(/#{search_term}/i)
        end
      end
    end
  end
end

def process_individual_album(album)
  loop do
    print "action ([d]isplay, [Y]AML, [q]uit): "
    exit 0 unless action = STDIN.gets
    action.chomp!
    puts

    case action
    when 'Y'
      puts YAML.dump(album)
    when 'd'
      puts album.display_formatted
    when 'q'
      return
    else
      puts "INVALID"
    end
  end
end

def process_all_albums
  current_count = Euterpe::Dashboard::Album.count
  refined_albums = []

  loop do
    if current_count > 30
      puts "\nThere are #{current_count} albums left to deal with, which is too many to display."
      puts "Please reduce the size of the list by entering an artist or album name.\n"

      print "artist or album name: "
      exit 0 unless search_term = STDIN.gets
      search_term.chomp!

      refined_albums = narrow_albums(refined_albums, search_term)
      current_count = refined_albums.size
    elsif 1 == current_count
      puts "\n\n"
      puts refined_albums.first.display_formatted(true) + "\n"
      process_individual_album(refined_albums.first)
      current_count = Euterpe::Dashboard::Album.count
      refined_albums = []
    elsif 0 == current_count
      puts "No albums matched your query or there are no albums remaining to process.\n\n"
      current_count = Euterpe::Dashboard::Album.count
      refined_albums = []
    else
      puts "\nThere are #{current_count} albums remaining in the list.\n\n"

      refined_albums = refined_albums.sort do |first,second|
        first.artist_name + first.name <=> second.artist_name + second.name
      end

      counter = 0
      refined_albums.each do |album|
        puts "#{counter = counter + 1}. #{album.artist_name}: #{album.name}"
      end

      puts "\nSelect an album from the above list for processing."

      print "\nalbum number (r to reset list): "
      break unless album_number = STDIN.gets
      album_number.chomp!
      puts
      
      case album_number
      when 'r'
        current_count = Euterpe::Dashboard::Album.count
        refined_albums = []
      else
        selected_album = refined_albums[album_number.to_i - 1]
        puts selected_album.display_formatted(true) + "\n"
        process_individual_album(selected_album)
      end
    end
  end
end

puts "::AOAIOXXYSZ:: music archive management system, v1"
puts "  e-mail Forrest (ogd@aoaioxxysz.net) if anything weird happens."
print "\nConnecting to database..."

ActiveRecord::Base.establish_connection(
  :adapter  => "postgresql",
  :username => "ogd",
  :database => "euterpe-dash-dev",
  :encoding => "SQL_ASCII"
)

puts "connected"

process_all_albums
