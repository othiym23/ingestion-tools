#!/usr/bin/env ruby
script_path = __FILE__
script_path = File.readlink(script_path) if File.symlink?(script_path)

$: << File.join(File.dirname(script_path), '../lib')

require 'jttui/jttui'
require 'jttui/jttuistd'
require 'yaml'
require 'logger'

require 'adaptor/euterpe_dashboard_factory' 
require 'ui/album_selection_model'
require 'ui/fln_widgets'

MY_LOGGER = Logger.new('jttui_trace.log')
#ActiveRecord::Base.logger = Logger.new('ingestion.log')

ARCHIVE_BASE = '/data/music/mp3'
PENDING_BASE = '/data/music/holding/pending'

STDOUT.sync = true
source_directory = File.expand_path(PENDING_BASE)
raise IOError.new("Path #{source_directory} does not exist!") unless File.exists?(source_directory)

at_exit { puts "\nSeeya!" }

# Hack into the guts of JTTui so I can see what it's doing, as well as
# patching a bug or two.

module JTTui
  alias_method :_send_message, :sendmessage
  def sendmessage(msg)
    log_message = "[#{msg[0].name}] received message #{msg[1]}"
    log_message << " '#{msg[2]}'" if msg[2]
    MY_LOGGER.info(log_message)
    _send_message(msg)
  end
end

class JTTWindow
  alias_method :_paint_self, :paintself
  def paintself(pc)
    MY_LOGGER.info("paintself: [#{@name}]")
    _paint_self(pc)
  end

  def visible=(v)
    if @visible ^ v
      @visible=v
      MY_LOGGER.info("FIXING JTTWindow.visible= by not exploding #{@name}'s message queue when pane " << (v ? "shown" : "hidden"))
      addmessage @parent, :paint
    end
  end
end

module Euterpe
  module Ingestion
    def self.connect_to_euterpe
      ActiveRecord::Base.establish_connection(
        :adapter  => "postgresql",
        :username => "ogd",
        :database => "euterpe-dash-dev",
        :encoding => "SQL_ASCII"
      )
    end
  end
end

class PendingStatus < FLNBorderlessPane
  def initialize(selection_model, parent, top, width)
    MY_LOGGER.info("PendingStatus.initialize starting")
    self.model = selection_model
    super(parent, self.class.name, width - 26, top, 26, 1, '')
    self.color = JTTui.aaxz_basic
  end

  def paintself(pc)
    message = current_message
    pc.move(self.w - message.length, 0)
    pc.addstra(message, JTTui.aaxz_important)
  end
  
  def model=(new_model)
    @model = new_model
    @model.add_observer(self)
  end
  
  def update(*args)
    addmessage self, :paint
  end

  def current_message
    message = @model.total.to_s << ' albums'
    if @model.selected
      message << ', 1 loaded'
    elsif @model.narrowed_list && @model.narrowed_list.size > 0
      message << ', ' << @model.narrowed_list.size.to_s << ' loaded'
    end
    
    message
  end
end

class AlbumList < JTTWList
  def initialize(*args, &block)
    @totalwidth = 1
    super
    @color = JTTui.aaxz_basic
    @color_basic = JTTui.aaxz_basic
    @color_active = JTTui.aaxz_reversed
  end

  def current_album
    @album_list[@focusedentry] if @album_list
  end
  
  def album_list=(list)
    @album_list = list
    update
  end
  
  def album_string(idx)
    "#{"%03d" % (idx + 1)}. #{@album_list[idx].artist_name} - #{@album_list[idx].name}" if @album_list
  end
  
  def update
    @totalwidth = 1
    @album_list.each_index{ |idx|
      cw = self.list_getitemsize(idx)[0]
      @totalwidth = cw if  cw > @totalwidth
    }
    updatescrollers
  end

  def list_getitemsize(idx)
    [self.w - 1, 1]
  end
  
  def list_drawitem(pc, hilighted, focused, idx)
    super
    pc.addstr album_string(idx)
  end

  def list_gettotalwidth
    @totalwidth
  end

  def list_getlength
    (@album_list.size if @album_list) || 0
  end

  def keypress(key)
    return false if list_keyonitem(key,@focusedentry)
    callupdate=true
    case key
    when 'up', 'C-p', 'u', 'k'   then step_minus
    when 'down', 'C-n', 'd', 'j' then step_plus
    when 'home', 'M-<'           then go_start
    when 'end', 'M->'            then go_end
    when 'pgup', 'M-v'           then view_minus
    when 'pgdn', 'C-v'           then view_plus

    when 'left', 'C-b'  then @scrollx.step_minus if @scrollx
    when 'right', 'C-f' then @scrollx.step_plus  if @scrollx
    when 'M-b'          then @scrollx.view_minus if @scrollx
    when 'M-f'          then @scrollx.view_plus  if @scrollx
    when 'C-a'          then @scrollx.go_start   if @scrollx
    when 'C-e'          then @scrollx.go_end     if @scrollx
    else
      callupdate=false
      addmessage @parent, :keypress, key
    end
    scrollaction if callupdate
  end

  def action
    @block.call(@album_list[@focusedentry]) if @block
  end
end

class Mode
  def initialize(selection_model, parent, control_pane, status_pane)
    @container = parent
    @model = selection_model
    @status = status_pane
    @control = control_pane
  end
  
  def enter
    # raise 'abstract operation raised directly!'
  end
  
  def exit
    # raise 'abstract operation raised directly!'
  end
  
  def update
    # raise 'abstract operation raised directly!'
  end
  
  protected
  
  def pass_the_buck(key)
    @status.message = ''
    @container.addmessage @container.parent, :keypress, key 
  end
end

class EditMode < Mode
  def enter
    @album_info_pane = FLNSlidingTextReader.new(@container, 'AlbumInfoPane',
                                                2, 1, @container.w - 4, @container.h - 5)
    @album_info_pane.list = @model.selected.display_formatted(true).split("\n")
    @album_info_pane.update
    
    @status.mode_label = 'Process album'
    @control.prompt_label = '[e]dit metadata [Y]AML dump [b]ack: '
  end
  
  def exit
    @album_info_pane.close if @album_info_pane
    @album_info_pane = nil

    @yaml_pane.close if @yaml_pane
    @yaml_pane = nil
  end
  
  def dispatch(key)
    case key
    when 'e'
      @status.message = 'TODO: album metadata editing'
    when 'h'
      @yaml_pane.visible = false if @yaml_pane
      @album_info_pane.visible = true if @album_info_pane

      @status.mode_label = 'Process album'
      @control.prompt_label = '[e]dit metadata [Y]AML dump [b]ack: '
      @status.message = ''
    when 'Y'
      @album_info_pane.visible = false
      
      unless @yaml_pane
        @yaml_pane = FLNSlidingTextReader.new(@container, 'YAMLPane',
                                              2, 1, @container.w - 4, @container.h - 5)
        @yaml_pane.list = YAML.dump(@model.selected).split("\n")
        @yaml_pane.update
      else
        @yaml_pane.visible = true
      end

      @status.mode_label = 'View YAML'
      @control.prompt_label = '[e]dit metadata [h]ide YAML [b]ack: '
      @status.message = ''
    when 'b', 'Q', 'q'
      @status.message = "Done with '#{@model.selected.name}'!"
      @model.selected = nil
    else
      pass_the_buck(key)
    end
  end
end

class BrowseMode < Mode
  def enter
    if !@chooser_pane
      @chooser_pane = AlbumList.new(@container, 'Album chooser',
                                    2, 1, @container.w - 4, @container.h - 5) do |album|
        @album_model.selected = album
      end
    elsif @chooser_pane.visible != true
      @chooser_pane.visible = true
    end
    
    update
  end
  
  def exit
    @chooser_pane.visible = false if @chooser_pane
  end
  
  def update
    @chooser_pane.album_list = @model.narrowed_list

    @status.mode_label = 'Choose album'
    if @model.list != @model.narrowed_list
      MY_LOGGER.info("original album list is [#{@model.list}] and current list is [#{@model.narrowed_list}]")
      @control.prompt_label = "[n]arrow results ([c]lear narrowing) [p]rocess highlighted album [b]ack: "
    else
      @control.prompt_label = "[n]arrow results [p]rocess highlighted album [b]ack: "
    end
    JTTui.activewindow = @chooser_pane
  end
  
  def dispatch(key)
    case key
    when 'n'
      get_additional_term
    when 'c'
      @model.clear_narrowing!
      @status.message = "narrowing cleared"
    when 'p', 'e', 'C-j', 'C-m'
      @model.selected = current_album
      @status.message = "selected #{current_album.artist_name} - #{current_album.name} for processing"
    when 'b', 'Q', 'q'
      reset
      @status.message = 'back to finding albums!'
    when ('0'..'9')
      get_line_jump(key)
    else
      pass_the_buck(key)
    end
  end
  
  def current_album
    @chooser_pane.current_album
  end
  
  private
  
  def reset
    @model.reset_list!
    @chooser_pane.close if @chooser_pane
    @chooser_pane = nil
  end
  
  def get_additional_term
    @control.prompt_with_callback('Narrow search', 'additional term: ', '') { |term| @model.narrow(term) }
  end

  def get_line_jump(key)
    @control.prompt_with_callback('Jump to line', 'line to jump to: ', key) do |selected|
      @chooser_pane.focusedentry = selected.to_i - 1
      @container.update
    end
  end
end

class SearchMode < Mode
  def enter
    set_status
    
    @model.reset_list! if @model.list
    @control.set_active!
  end
  
  def dispatch(key)
    case key
    when 'f'
      get_albums
    when 'r'
      random = AlbumDao.choose_randomly
      @model.selected = random
      @status.message = "#{random.artist_name} - #{random.name} chosen at random for processing"
    when 'm'
      recent = AlbumDao.choose_most_recent
      @model.selected = recent
      @status.message = "#{recent.artist_name} - #{recent.name} is the most recently added album"
    when 'Q', 'q'
      @status.message = ''
      @container.addmessage nil, :quitloop, key
    else
      pass_the_buck(key)
    end
  end
  
  private
  
  def set_status
    @status.mode_label = 'Top level'
    @control.prompt_label = '[f]ind albums [r]andom album [m]ost recent album [q]uit: '
  end
  
  def get_albums
    @control.prompt_with_callback('Find albums', 'cached metadata search: ', '') do |query|
      find_albums(query) 
      @container.update
    end
  end
  
  def find_albums(query)
    MY_LOGGER.info("SearchMode.find_albums looking for term #{query}")
    @status.message = "searching Euterpe metadata cache for albums mentioning '#{query}'..."

    start_time = Time.now
    query.chomp!
    @model.reset_list!
    @model.narrow(query)
    finish_time = Time.now

    time = finish_time - start_time
    
    MY_LOGGER.info("SearchMode.find_albums found [#{@model.list}]")
    found_albums = @model.list || []
    case found_albums.size
    when 0
      @status.message = "no results (query ran in #{time.to_f} seconds)"
      set_status
    when 1
      @status.message = "single album found in #{time.to_f} seconds"
      @model.selected = found_albums.first
    else
      @status.message = "#{found_albums.size} records found in #{time.to_f} seconds"
    end
  end
end

class StatusPane < FLNBorderlessPane
  def initialize(model, parent, left, top, width)
    super(parent, self.class.name, left, top, width, 3, '')
    @color = JTTui.aaxz_basic

    @mode_label = JTTWLabel.new(self, 'mode_label', 0, 0, self.w, 1, '')
    @mode_label.color = JTTui.aaxz_basic
    
    @status_line = FLNImmediateLabel.new(self, 'status_line', 0, self.h - 1, self.w - 26, 1, '')
    @pending = PendingStatus.new(model, self, self.h - 1, self.w)
  end

  def mode_label=(mode_name)
    @mode_label.caption = mode_name
  end
  
  def message=(value)
    @status = value || ''
    @status_line.caption = @status
  end
end

class ControlPane
  def initialize(parent, top, width)
    MY_LOGGER.info("ControlPane.initialize starting")
    @parent = parent

    @prompt_label = JTTWLabel.new(parent, 'prompt_label', 0, top, width, 1, 'LOADING')
    @prompt_label.color = JTTui.aaxz_basic
  end
  
  def prompt_label=(value)
    @prompt_label.caption = value
  end
  
  def prompt_with_callback(mode_label, prompt_string, initial_value, &block)
    @parent.message = ''
    @parent.mode_label = mode_label
    @prompt_label.caption = prompt_string

    @prompt_field = FLNButtonlessEditline.new(@parent, 'prompt_field',
                                              prompt_string.size - 1, @parent.h - 2, 
                                              @parent.w - (prompt_string.size + 2), 1, '', true)
    @prompt_field.get_finished(initial_value, &block)
    JTTui.activewindow = @prompt_field
    
    @parent.addmessage @parent, :paint
  end
  
  def set_active!
    JTTui.activewindow = @prompt_label
  end
end

class ProcessingApplication < FLNBorderlessPane
  attr_reader :prompt_label
  
  def initialize(parent)
    MY_LOGGER.info("ProcessingWindow.initialize setting up GUI")
    self.visible = false
    super(parent, self.class.name, 0, 0, parent.w, parent.h, '')
    @color = JTTui.aaxz_basic
    
    @album_model = AlbumSelectionModel.new
    @album_model.add_observer(self)
    
    @status_pane = StatusPane.new(@album_model, self, 0, self.h - 3, self.w)
    MY_LOGGER.info("Status pane is #{@status_pane}")
    @album_model.status = @status_pane
    
    @control_pane = ControlPane.new(@status_pane, @status_pane.h - 2, @status_pane.w)
    
    @status_pane.message = "Connecting to metadata cache..."
    Euterpe::Ingestion::connect_to_euterpe
    @status_pane.message = 'Connected to metadata cache'
    
    @edit_mode = EditMode.new(@album_model, self, @control_pane, @status_pane)
    @browse_mode = BrowseMode.new(@album_model, self, @control_pane, @status_pane)
    @search_mode = SearchMode.new(@album_model, self, @control_pane, @status_pane)
    
    @album_model.total = Euterpe::Dashboard::Album.count
    self.visible = true
    MY_LOGGER.info("#{@album_model.total} albums loaded")
  end
  
  def keypress(key)
    @current_mode.dispatch(key)
  end
  
  def update(*args)
    MY_LOGGER.info("ProcessingWindow.update#before with mode #{@current_mode}")

    if @album_model.selected
      new_mode = @edit_mode
    elsif @album_model.list && @album_model.list.size > 1
      new_mode = @browse_mode
    else
      new_mode = @search_mode
    end
    
    if new_mode != @current_mode
      @current_mode.exit if @current_mode
      @current_mode = new_mode
      @current_mode.enter

      addmessage self, :paint
    else
      @current_mode.update if @current_mode
    end

    MY_LOGGER.info("ProcessingWindow.update#after with mode #{@current_mode}")
  end

  def paintself(pc)
    super(pc)
    pc.move(4, 2)
    pc.addstra("::AOAIOXXYSZ:: music archive management system, v1", JTTui.aaxz_basic)
    pc.move(6, 3)
    pc.addstra("e-mail Forrest (ogd@aoaioxxysz.net) if anything weird happens.", JTTui.aaxz_basic)
  end
end

JTTui.run do |root|
  JTTColor.new('aaxz_basic', JTCur.color_white, JTCur.color_black, 0, 0).recompute
  JTTColor.new('aaxz_important', JTCur.color_white, JTCur.color_black, JTCur.attr_bold, JTCur.attr_bold).recompute
  JTTColor.new('aaxz_reversed', JTCur.color_black, JTCur.color_white, JTCur.attr_bold, JTCur.attr_bold).recompute
  JTTColor.new('color_edit_dis', JTCur.color_white, JTCur.color_black, 0, 0).recompute
  JTTColor.new('color_edit', JTCur.color_white, JTCur.color_black, JTCur.attr_bold, JTCur.attr_bold).recompute
  JTTColor.new('color_edit_hi', JTCur.color_white, JTCur.color_black, JTCur.attr_bold, JTCur.attr_bold).recompute

  processing = ProcessingApplication.new(root)
end