#!/usr/bin/env ruby
script_path = __FILE__
script_path = File.readlink(script_path) if File.symlink?(script_path)

$: << File.join(File.dirname(script_path), '../lib')

require 'jttui/jttui'
require 'jttui/jttuistd'
require 'yaml'
require 'logger'
require 'singleton'

require 'adaptor/euterpe_dashboard_factory' 
require 'ui/album_selection_model'
require 'ui/fln_widgets'

MY_LOGGER = Logger.new('jttui_trace.log')
MY_LOGGER.level = Logger::DEBUG
#ActiveRecord::Base.logger = Logger.new('ingestion.log')

ARCHIVE_BASE = '/data/music/mp3'
PENDING_BASE = '/data/music/holding/pending'

STDOUT.sync = true
source_directory = File.expand_path(PENDING_BASE)
raise IOError.new("Path #{source_directory} does not exist!") unless File.exists?(source_directory)

at_exit { puts "\nSeeya!" }

# Hack into the guts of JTTui so I can log what it's doing.
module JTTui
  alias_method :_add_message, :addmessage
  def addmessage(*msg)
    target_name = (msg[0] ? msg[0].name : 'ROOT CONTEXT')
    log_message = "[#{target_name}] target for newly added message #{msg[1]}"
    log_message << " '#{msg[2]}'" if msg[2]
    MY_LOGGER.debug(log_message)
    _add_message(*msg)
  end

  alias_method :_del_messages, :delmessages
  def delmessages(*msg)
    target_name = (msg[0] ? msg[0].name : 'ROOT CONTEXT')
    log_message = "[#{target_name}] target for newly added message #{msg[1]}"
    log_message << " '#{msg[2]}'" if msg[2]
    MY_LOGGER.debug(log_message)
    _del_messages(*msg)
  end

  alias_method :_send_message, :sendmessage
  def sendmessage(msg)
    log_message = "[#{msg[0].name}] received message #{msg[1]}"
    log_message << " '#{msg[2]}'" if msg[2]
    MY_LOGGER.debug(log_message)
    _send_message(msg)
  end
end

class JTTWindow
  alias_method :_paint_self, :paintself
  def paintself(pc)
    MY_LOGGER.debug("paintself: [#{@name}]")
    _paint_self(pc)
  end
  
  # PATCH: the JTTui code calls paint directly when visible= is invoked,
  # breaking the refresh model for the component affected, as well as all
  # its children
  def visible=(v)
    if @visible ^ v
      @visible=v
      MY_LOGGER.warn("FIXING JTTWindow.visible= by not exploding #{@name}'s message queue when pane " << (v ? "shown" : "hidden"))
      addmessage @parent, :paint
    end
  end
end

module Euterpe
  module Ingestion
    def self.connect_to_euterpe
      ActiveRecord::Base.establish_connection(
        :adapter  => "postgresql",
        :username => "ogd",
        :database => "euterpe-dash-dev",
        :encoding => "SQL_ASCII"
      )
    end
  end
end

class PendingStatus < FLNBorderlessPane
  def initialize(selection_model, parent, top, width)
    MY_LOGGER.info("PendingStatus initialization started")
    self.model = selection_model
    super(parent, self.class.name, width - 26, top, 26, 1, '')
    self.color = JTTui.aaxz_basic
    MY_LOGGER.info("PendingStatus initialization complete")
  end

  def paintself(pc)
    message = current_message
    pc.move(self.w - message.length, 0)
    pc.addstra(message, JTTui.aaxz_important)
  end
  
  def model=(new_model)
    @model = new_model
    @model.add_observer(self)
  end
  
  def update(*args)
    addmessage self, :paint
  end

  def current_message
    message = @model.total.to_s << ' albums'
    if @model.selected
      message << ', 1 loaded'
    elsif @model.narrowed_list && @model.narrowed_list.size > 0
      message << ', ' << @model.narrowed_list.size.to_s << ' loaded'
    end
    
    message
  end
end

class AlbumList < JTTWList
  def initialize(*args, &block)
    @totalwidth = 1
    super
    @color = JTTui.aaxz_basic
    @color_basic = JTTui.aaxz_basic
    @color_active = JTTui.aaxz_reversed
  end

  def current_album
    @album_list[@focusedentry] if @album_list
  end
  
  def album_list=(list)
    @album_list = list
    update
  end
  
  def album_string(idx)
    "#{"%03d" % (idx + 1)}. #{@album_list[idx].artist_name} - #{@album_list[idx].reconstituted_name}" if @album_list
  end
  
  def update
    @totalwidth = 1
    @album_list.each_index{ |idx|
      cw = self.list_getitemsize(idx)[0]
      @totalwidth = cw if  cw > @totalwidth
    }
    updatescrollers
  end

  def list_getitemsize(idx)
    [self.w - 1, 1]
  end
  
  def list_drawitem(pc, hilighted, focused, idx)
    super(pc, hilighted, true, idx)
    pc.addstr album_string(idx)
  end

  def list_gettotalwidth
    @totalwidth
  end

  def list_getlength
    (@album_list.size if @album_list) || 0
  end

  def keypress(key)
    return false if list_keyonitem(key,@focusedentry)
    callupdate=true
    case key
    when 'up', 'C-p', 'u', 'k'   then step_minus
    when 'down', 'C-n', 'd', 'j' then step_plus
    when 'home', 'M-<'           then go_start
    when 'end', 'M->'            then go_end
    when 'pgup', 'M-v'           then view_minus
    when 'pgdn', 'C-v'           then view_plus

    when 'left', 'C-b'  then @scrollx.step_minus if @scrollx
    when 'right', 'C-f' then @scrollx.step_plus  if @scrollx
    when 'M-b'          then @scrollx.view_minus if @scrollx
    when 'M-f'          then @scrollx.view_plus  if @scrollx
    when 'C-a'          then @scrollx.go_start   if @scrollx
    when 'C-e'          then @scrollx.go_end     if @scrollx
    else
      callupdate=false
      addmessage @parent, :keypress, key
    end
    scrollaction if callupdate
  end

  def action
    @block.call(@album_list[@focusedentry]) if @block
  end
end

class IllegalStateError < StandardError; end

class ControllerState
  include Singleton
  attr_writer :model, :context, :control, :status
  
  def ControllerState.default
    default_instance = instance
    default_instance.model = self.model
    default_instance.context = self.context
    default_instance.control = self.control
    default_instance.status = self.status
    
    default_instance
  end
  
  def enter
    MY_LOGGER.warn("[#{self.class.name}] abstract method 'enter' called")
  end
  
  def exit
    MY_LOGGER.warn("[#{self.class.name}] abstract method 'exit' called")
  end
  
  def update
    MY_LOGGER.warn("[#{self.class.name}] abstract method 'update' called")
  end
  
  protected
  
  def self.context
    @@context
  end
  
  def self.context=(new_context)
    @@context = new_context
  end
  
  def self.model
    @@model
  end
  
  def self.model=(new_model)
    @@model = new_model
  end
  
  def self.status
    @@status
  end
  
  def self.status=(new_status)
    @@status = new_status
  end
  
  def self.control
    @@control
  end
  
  def self.control=(new_control)
    @@control = new_control
  end
  
  def pass_the_buck(key)
    @status.message = ''
    @context.addmessage @context.parent, :keypress, key 
  end
end

class AlbumMusicBrainzEditState < ControllerState
  def AlbumMusicBrainzEditState.state_name
    'Edit album-level MusicBrainz metadata'
  end
  
  def prompt_string
    'album [i]d a[r]tist id | release [t]ype [s]tatus [c]ountry | [b]ack: '
  end
  
  def enter
    unless @model.selected
      raise IllegalStateError.new("#{self.class.name} requires an album be selected")
    end
    
    @status.message = 'WARNING: populating this data by hand isn\'t a good idea. Use the matcher.'
    @album_info_pane = @context.get_panel(FLNSlidingTextReader)
    @context.set_active
  end
  
  def exit
    @album_info_pane.visible = false
  end
  
  def update
    @album_info_pane.list = @model.selected.musicbrainz_info_formatted(false, false).split("\n")
    @album_info_pane.update
    @album_info_pane.visible = true unless @album_info_pane.visible
  end
  
  def dispatch(key)
    case key
    when 'i'
      get_musicbrainz_album_id
    when 'r'
      get_musicbrainz_album_artist_id
    when 't'
      get_musicbrainz_album_release_type
    when 's'
      get_musicbrainz_album_release_status
    when 'c'
      get_musicbrainz_album_release_country
    when 'b', 'Q', 'q'
      @context.change_state(EditState)
    else
      @album_info_pane.keypress(key)
    end
  end

  def get_musicbrainz_album_id
    @control.prompt_with_callback('Edit MusicBrainz album metadata', 'MusicBrainz album id: ', @model.selected.musicbrainz_album_id) do |input|
      @model.selected.musicbrainz_album_id = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_musicbrainz_album_artist_id
    @control.prompt_with_callback('Edit MusicBrainz album metadata', 'MusicBrainz album artist id: ', @model.selected.musicbrainz_album_artist_id) do |input|
      @model.selected.musicbrainz_album_artist_id = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_musicbrainz_album_release_type
    @status.message = 'Valid values are "album", "single", "live", "e.p."'
    @control.prompt_with_callback('Edit MusicBrainz album metadata', 'MusicBrainz album release type: ', @model.selected.musicbrainz_album_type) do |input|
      @model.selected.musicbrainz_album_type = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_musicbrainz_album_release_status
    @status.message = 'Valid values are "official", "promotional", or "bootleg"'
    @control.prompt_with_callback('Edit MusicBrainz album metadata', 'MusicBrainz album release status: ', @model.selected.musicbrainz_album_status) do |input|
      @model.selected.musicbrainz_album_status = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_musicbrainz_album_release_country
    @status.message = 'Use two-character ISO country codes (US, UK, JP, DE)'
    @control.prompt_with_callback('Edit MusicBrainz album metadata', 'MusicBrainz album release country: ', @model.selected.musicbrainz_album_release_country) do |input|
      @model.selected.musicbrainz_album_release_country = ('' == input ? nil : input.upcase)
      @context.update
    end
  end
end

class AlbumMetadataEditState < ControllerState
  def AlbumMetadataEditState.state_name
    'Edit album-level metadata'
  end
  
  def prompt_string
    '[n]ame [s]ort [a]rtist ([S]ort) [y]ear [g]enre [c]omp? [m]ixed by sub[t]itle [v]ersion [M]usicBrainz [b]ack: '
  end
  
  def enter
    unless @model.selected
      raise IllegalStateError.new("#{self.class.name} requires an album be selected")
    end
    
    @album_info_pane = @context.get_panel(FLNSlidingTextReader)
    @context.set_active
  end
  
  def exit
    @album_info_pane.visible = false
  end
  
  def update
    @album_info_pane.list = @model.selected.album_header_formatted(false, false).split("\n")
    @album_info_pane.update
    @album_info_pane.visible = true unless @album_info_pane.visible
  end
  
  def dispatch(key)
    case key
    when 'n'
      get_album_name
    when 's'
      get_album_sort_order
    when 'a'
      get_album_artist_name
    when 'S'
      get_album_artist_sort_order
    when 'y'
      get_album_release_year
    when 'g'
      get_album_genre
    when 'm'
      get_album_mixed_by
    when 'c'
      toggle_album_compilation
    when 't'
      get_album_subtitle
    when 'v'
      get_album_version
    when 'b', 'Q', 'q'
      @context.change_state(EditState)
    when 'M'
      @context.change_state(AlbumMusicBrainzEditState)
    else
      @album_info_pane.keypress(key)
    end
  end

  def get_album_name
    @status.message = ''
    @control.prompt_with_callback('Edit album metadata', 'album name: ', @model.selected.name) do |input|
      @model.selected.name = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_album_sort_order
    @status.message = ''
    @control.prompt_with_callback('Edit album metadata', 'sort name: ', @model.selected.sort_order) do |input|
      @model.selected.sort_order = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_album_subtitle
    @status.message = 'Only some albums have subtitles, generally following colons'
    @control.prompt_with_callback('Edit album metadata', 'subtitle: ', @model.selected.subtitle) do |input|
      @model.selected.subtitle = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_album_version
    @status.message = 'Use the album version to disambiguate between independent releases'
    @control.prompt_with_callback('Edit album metadata', 'version: ', @model.selected.version_name) do |input|
      @model.selected.version_name = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_album_genre
    @status.message = 'Automatically propagate the album\'s genre out to the tracks'
    @control.prompt_with_callback('Edit album metadata', 'genre: ', @model.selected.genre) do |input|
      @model.selected.genre = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_album_artist_name
    @status.message = ''
    @control.prompt_with_callback('Edit album metadata', 'artist name: ', @model.selected.artist_name) do |input|
      @model.selected.artist_name = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_album_artist_sort_order
    @status.message = ''
    @control.prompt_with_callback('Edit album metadata', 'artist sort name: ', @model.selected.artist_sort_order) do |input|
      @model.selected.artist_sort_order = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_album_mixed_by
    @status.message = 'Reserve this attribute for continuous mixes.'
    @control.prompt_with_callback('Edit album metadata', 'mixed by: ', @model.selected.mixer) do |input|
      @model.selected.mixer = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_album_release_year
    @status.message = ''
    @control.prompt_with_callback('Edit album metadata', 'artist sort name: ', @model.selected.release_date) do |input|
      @model.selected.release_date = ('' == input ? nil : input)
      @context.update
    end
  end
  
  def toggle_album_compilation
    if @model.selected.compilation
      @model.selected.compilation = !@model.selected.compilation
      @status.message = 'album was compilation, but now it\'s not'
    else
      @model.selected.compilation = !@model.selected.compilation
      @status.message = 'album wasn\'t a compilation, but now it is'
    end
  end
end

class AlbumYAMLState < ControllerState
  def AlbumYAMLState.state_name
    'View YAML'
  end
  
  def prompt_string
    '[e]dit metadata [h]ide YAML [b]ack: '
  end
  
  def enter
    unless @model.selected
      raise IllegalStateError.new("#{self.class.name} requires an album be selected")
    end
    
    @yaml_pane = @context.get_panel(FLNSlidingTextReader)
    @context.set_active
  end
  
  def exit
    @yaml_pane.visible = false
  end
  
  def update
    @yaml_pane.list = YAML.dump(content).split("\n")
    @yaml_pane.update
    @yaml_pane.visible = true unless @yaml_pane.visible
  end
  
  def dispatch(key)
    case key
    when 'e'
      @status.message = ''
      edit
    when 'h'
      hide
    when 'b', 'Q', 'q'
      prev_mode
    else
      @yaml_pane.keypress(key)
    end
  end
  
  def edit
    @context.change_state(AlbumMetadataEditState)
  end
  
  def hide
    @status.message = ''
    @context.change_state(EditState)
  end
  
  def content
    @model.selected
  end
  
  def prev_mode
    @status.message = "Done with '#{@model.selected.reconstituted_name}'!"
    @model.selected = nil

    if @model.list && @model.list.size > 0
      @context.change_state(BrowseState)
    else
      @context.change_state(StartState)
    end
  end
end

class TrackYAMLState < AlbumYAMLState
  def enter(track)
    unless track
      raise IllegalStateError.new("#{self.class.name} requires a track be selected")
    end
    
    @selected_track = track

    @yaml_pane = @context.get_panel(FLNSlidingTextReader)
    @context.set_active
  end
  
  def content
    @selected_track
  end
  
  def hide
    edit
  end

  def edit
    @status.message = ''
    @context.change_state(TrackMetadataEditState, @selected_track)
  end
  
  def prev_mode
    @status.message = "Done viewing YAML for '#{@selected_track.reconstituted_name}'!"
    @context.change_state(EditState)
  end
end

class TrackMetadataEditState < ControllerState
  def TrackMetadataEditState.state_name
    'Edit track-level metadata'
  end
  
  def prompt_string
    '[n]ame [s]ort [a]rtist ([S]ort) [r]emix [g]enre [y]ear [f]eat. [c]omment [M]usicBrainz ([Y]AML) [b]ack: '
  end
  
  def enter(track)
    unless track
      raise IllegalStateError.new("#{self.class.name} requires a track be selected")
    end
    
    @selected_track = track
    
    @track_info_pane = @context.get_panel(FLNSlidingTextReader)
    @context.set_active
  end
  
  def exit
    @track_info_pane.visible = false
  end
  
  def update
    @track_info_pane.list = @selected_track.display_formatted(false, false).split("\n")
    @track_info_pane.update
    @track_info_pane.visible = true unless @track_info_pane.visible
  end
  
  def dispatch(key)
    case key
    when 'n'
      get_track_name
    when 's'
      get_track_sort_order
    when 'a'
      get_track_artist_name
    when 'S'
      get_track_artist_sort_order
    when 'y'
      get_track_release_year
    when 'g'
      get_track_genre
    when 'r'
      get_track_remix_name
    when 'c'
      get_track_comment
    when 'f'
      @status.message = 'TODO: featured artist editing mode'
    when 'b', 'Q', 'q'
      @status.message = "Done with track '#{@selected_track.name}'!"
      @context.change_state(EditState)
    when 'M'
      @context.change_state(TrackMusicBrainzEditState, @selected_track)
    when 'Y'
      @context.change_state(TrackYAMLState, @selected_track)
    else
      @track_info_pane.keypress(key)
    end
  end

  def get_track_name
    @status.message = ''
    @control.prompt_with_callback('Edit track metadata', 'album name: ', @selected_track.name) do |input|
      @selected_track.name = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_track_sort_order
    @status.message = ''
    @control.prompt_with_callback('Edit track metadata', 'sort name: ', @selected_track.sort_order) do |input|
      @selected_track.sort_order = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_track_release_year
    @status.message = ''
    @control.prompt_with_callback('Edit track metadata', 'artist sort name: ', @selected_track.release_date) do |input|
      @selected_track.release_date = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_track_artist_name
    @status.message = ''
    @control.prompt_with_callback('Edit track metadata', 'artist name: ', @selected_track.artist_name) do |input|
      @selected_track.artist_name = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_track_artist_sort_order
    @status.message = ''
    @control.prompt_with_callback('Edit track metadata', 'artist sort name: ', @selected_track.artist_sort_order) do |input|
      @selected_track.artist_sort_order = ('' == input ? nil : input)
      @context.update
    end
  end
  
  def get_track_genre
    @status.message = ''
    @control.prompt_with_callback('Edit track metadata', 'genre: ', @selected_track.genre) do |input|
      @selected_track.genre = ('' == input ? nil : input)
      @context.update
    end
  end
  
  def get_track_remix_name
    @status.message = ''
    @control.prompt_with_callback('Edit track metadata', 'remix: ', @selected_track.remix) do |input|
      @selected_track.remix = ('' == input ? nil : input)
      @context.update
    end
  end
  
  def get_track_comment
    @status.message = ''
    @control.prompt_with_callback('Edit track metadata', 'comment: ', @selected_track.format_comments) do |input|
      @selected_track.comment = ('' == input ? nil : input)
      @context.update
    end
  end
end

class TrackMusicBrainzEditState < ControllerState
  def TrackMusicBrainzEditState.state_name
    'Edit track-level MusicBrainz metadata'
  end
  
  def prompt_string
    'track [i]d a[r]tist id [b]ack: '
  end
  
  def enter(track)
    unless track
      raise IllegalStateError.new("#{self.class.name} requires an album be selected")
    end
    
    @selected_track = track
    
    @status.message = 'WARNING: populating this data by hand isn\'t a good idea. Use the matcher.'
    @track_info_pane = @context.get_panel(FLNSlidingTextReader)
    @context.set_active
  end
  
  def exit
    @track_info_pane.visible = false
  end
  
  def update
    @track_info_pane.list = @selected_track.musicbrainz_info_formatted.split("\n")
    @track_info_pane.update
    @track_info_pane.visible = true unless @track_info_pane.visible
  end
  
  def dispatch(key)
    case key
    when 'i'
      get_musicbrainz_track_id
    when 'r'
      get_musicbrainz_track_artist_id
    when 'b', 'Q', 'q'
      @context.change_state(TrackMetadataEditState, @selected_track)
    else
      @track_info_pane.keypress(key)
    end
  end

  def get_musicbrainz_track_id
    @control.prompt_with_callback('Edit MusicBrainz track metadata', 'MusicBrainz track id: ', @selected_track.unique_id) do |input|
      @selected_track.unique_id = ('' == input ? nil : input)
      @context.update
    end
  end

  def get_musicbrainz_track_artist_id
    @control.prompt_with_callback('Edit MusicBrainz track metadata', 'MusicBrainz track artist id: ', @selected_track.musicbrainz_artist_id) do |input|
      @selected_track.musicbrainz_artist_id = ('' == input ? nil : input)
      @context.update
    end
  end
end

class EditState < ControllerState
  def EditState.state_name
    'Album information'
  end
  
  def prompt_string
    'edit [a]lbum or [t]rack (get [Y]AML dump) [b]ack: '
  end
  
  def enter
    unless @model.selected
      raise IllegalStateError.new("#{self.class.name} requires an album be selected")
    end
    
    @status.message = "Displaying #{@model.selected.artist_name} - #{@model.selected.reconstituted_name}"
    @album_info_pane = @context.get_panel(FLNSlidingTextReader)
    @context.set_active
  end
  
  def exit
    @album_info_pane.visible = false
  end
  
  def update
    if @model.selected
      @album_info_pane.list = @model.selected.display_formatted(false).split("\n")
      @album_info_pane.update
      @album_info_pane.visible = true unless @album_info_pane.visible
    end
  end
  
  def dispatch(key)
    case key
    when 'a'
      @status.message = ''
      @context.change_state(AlbumMetadataEditState)
    when 't'
      get_track_to_edit
    when 'Y'
      @status.message = ''
      @context.change_state(AlbumYAMLState)
    when 'b', 'Q', 'q'
      @status.message = "Done with '#{@model.selected.reconstituted_name}'!"
      @model.selected = nil
      
      if @model.list && @model.list.size > 0
        @context.change_state(BrowseState)
      else
        @context.change_state(StartState)
      end
    when ('0'..'9')
      get_track_to_edit(key)
    else
      @album_info_pane.keypress(key)
    end
  end

  def get_track_to_edit(initial_string = '')
    @status.message = 'Enter the track to edit as disc.track (disc number is optional)'
    @control.prompt_with_callback('Choose track to edit', 'disc.track: ', initial_string) do |input|
      disc_number, track_number = input.split('.')
      if nil == track_number
        track_number = disc_number.to_i
        disc_number = 1
      else
        track_number = track_number.to_i
        disc_number = disc_number.to_i
      end
      
      track = @model.selected.track(disc_number, track_number)
      if track
        @status.message = "Editing metadata for '#{track.reconstituted_name}'"
        @context.change_state(TrackMetadataEditState, track)
      else
        @status.message = 'Invalid track!'
        @context.update
      end
    end
  end
end

class BrowseState < ControllerState
  def BrowseState.state_name
    'Choose album'
  end
  
  def prompt_string
    if @model.list != @model.narrowed_list
      MY_LOGGER.info("original album list is [#{@model.list}] and current list is [#{@model.narrowed_list}]")
      '[n]arrow results ([c]lear narrowing) [p]rocess highlighted album [b]ack: '
    else
      '[n]arrow results [p]rocess highlighted album [b]ack: '
    end
  end
  
  def enter
    unless @model.narrowed_list
      raise IllegalStateError.new("#{self.class.name} requires a list of albums be available")
    end
    
    @chooser_pane = @context.get_panel(AlbumList)
    @context.set_active
  end
  
  def exit
    @chooser_pane.visible = false if @chooser_pane
  end
  
  def update
    @chooser_pane.album_list = @model.narrowed_list
    @chooser_pane.update
    @chooser_pane.visible = true unless @chooser_pane.visible
  end
  
  def dispatch(key)
    case key
    when 'n'
      get_additional_term
    when 'c'
      @model.clear_narrowing!
      @status.message = "narrowing cleared"
    when 'p', 'e', 'C-j', 'C-m'
      @status.message = "selected #{current_album.artist_name} - #{current_album.reconstituted_name} for processing"
      @model.selected = current_album
      @context.change_state(EditState)
    when 'b', 'Q', 'q'
      @status.message = 'back to finding albums!'
      @context.change_state(StartState)
    when ('0'..'9')
      get_line_jump(key)
    else
      @chooser_pane.keypress(key)
    end
  end
  
  def current_album
    @chooser_pane.current_album
  end
  
  private
  
  def get_additional_term
    @control.prompt_with_callback('Narrow search', 'additional term: ', '') do |term|
      @model.narrow(term)
      if @model.selected
        @context.change_state(EditState)
      else
        @context.update
      end
    end
  end

  def get_line_jump(key)
    @control.prompt_with_callback('Jump to line', 'line to jump to: ', key) do |selected|
      @chooser_pane.focusedentry = selected.to_i - 1
      @context.update
    end
  end
end

class StartState < ControllerState
  def StartState.state_name
    'Top level'
  end
  
  def prompt_string
    '[f]ind albums [r]andom album [m]ost recent album [q]uit: '
  end
  
  def enter
    @model.reset_list! if @model.list
  end
  
  def dispatch(key)
    case key
    when 'f'
      get_albums
    when 'r'
      random = AlbumDao.choose_randomly
      @status.message = "#{random.artist_name} - #{random.reconstituted_name} chosen at random for processing"
      @model.selected = random
      @context.change_state(EditState)
    when 'm'
      recent = AlbumDao.choose_most_recent
      @status.message = "#{recent.artist_name} - #{recent.reconstituted_name} is the most recently added album"
      @model.selected = recent
      @context.change_state(EditState)
    when 'Q', 'q'
      @status.message = ''
      @context.addmessage nil, :quitloop, key
    else
      pass_the_buck(key)
    end
  end
  
  private
  
  def get_albums
    @status.message = ''
    @control.prompt_with_callback('Find albums', 'cached metadata search: ', '') do |query|
      @status.message = "searching Euterpe metadata cache for albums mentioning '#{query}'..."

      start_time = Time.now
      query.chomp!
      @model.narrow(query)
      finish_time = Time.now

      time = finish_time - start_time

      found_albums = @model.narrowed_list || [@model.selected] || []
      case found_albums.size
      when 0
        @status.message = "no results (query ran in #{time.to_f} seconds)"
      when 1
        @status.message = "single album found in #{time.to_f} seconds"
        @model.selected = found_albums.first
        @context.change_state(EditState)
        MY_LOGGER.debug("SearchMode.find_albums found '#{found_albums.first.name}'")
      else
        @status.message = "#{found_albums.size} records found in #{time.to_f} seconds"
        @context.change_state(BrowseState)
        MY_LOGGER.debug("SearchMode.find_albums found [#{@model.list.map{|album| album.name}.join(', ')}]")
      end
    end
  end
end

class StatusPane < FLNBorderlessPane
  def initialize(model, parent, left, top, width)
    MY_LOGGER.info("StatusPane initialization started")
    super(parent, self.class.name, left, top, width, 3, '')
    @color = JTTui.aaxz_basic

    @state_label = JTTWLabel.new(self, 'state_label', 0, 0, self.w, 1, '')
    @state_label.color = JTTui.aaxz_basic
    
    @status_line = FLNImmediateLabel.new(self, 'status_line', 0, self.h - 1, self.w - 26, 1, '')
    @pending = PendingStatus.new(model, self, self.h - 1, self.w)
    MY_LOGGER.info("StatusPane initialization complete")
  end

  def state_label=(mode_name)
    @state_label.caption = mode_name
  end
  
  def message=(value)
    MY_LOGGER.info("#{self.class.name} message '#{value}'")
    @status = value || ''
    @status_line.caption = @status
  end
end

class ControlPane
  def initialize(parent, top, width)
    MY_LOGGER.info("ControlPane initialization started")
    @parent = parent

    @prompt_label = JTTWLabel.new(parent, 'prompt_label', 0, top, width, 1, 'LOADING')
    @prompt_label.color = JTTui.aaxz_basic
    MY_LOGGER.info("ControlPane initialization complete")
  end
  
  def prompt_label=(value)
    @prompt_label.caption = value
  end
  
  def prompt_with_callback(state_label, prompt_string, initial_value, &block)
    @parent.state_label = state_label
    @prompt_label.caption = prompt_string

    @prompt_field = FLNButtonlessEditline.new(@parent, 'prompt_field',
                                              prompt_string.size - 1, @parent.h - 2, 
                                              @parent.w - (prompt_string.size + 2), 1, '', true)
    @prompt_field.get_finished(initial_value || '', &block)
    JTTui.activewindow = @prompt_field
    
    @parent.addmessage @parent, :paint
  end
  
  def set_active!
    JTTui.activewindow = @prompt_label
  end
end

class ProcessingApplication < FLNBorderlessPane
  attr_reader :prompt_label
  
  def initialize(parent)
    MY_LOGGER.info("ProcessingApplication initialization started")
    self.visible = false
    
    super(parent, self.class.name, 0, 0, parent.w, parent.h, '')
    @color = JTTui.aaxz_basic
    
    @album_model = AlbumSelectionModel.new
    
    @status_pane = StatusPane.new(@album_model, self, 0, self.h - 3, self.w)
    @album_model.status = @status_pane
    
    @control_pane = ControlPane.new(@status_pane, @status_pane.h - 2, @status_pane.w)
    
    @status_pane.message = "Connecting to metadata cache..."
    Euterpe::Ingestion::connect_to_euterpe
    @status_pane.message = 'Connected to metadata cache'
    
    ControllerState.model = @album_model
    ControllerState.context = self
    ControllerState.control = @control_pane
    ControllerState.status = @status_pane

    @current_state = StartState.default
    
    @album_model.add_observer(self)
    @album_model.total = Euterpe::Dashboard::Album.count
    MY_LOGGER.info("#{@album_model.total} albums loaded")
    
    self.visible = true
    MY_LOGGER.info("ProcessingApplication initialization complete")
  end
  
  def keypress(key)
    # Due to the way the application delegates input to controller objects,
    # which in turn delegate messages to the JTTui components they control,
    # we need to clear the message queue here to ensure we don't get stuck in
    # an infinite loop as the application dispatches to the controller, which
    # dispatches to its component delegate(s), which propagates the message to
    # its container (this object), ad infinitum.
    delmessages self, :keypress
    @current_state.dispatch(key)
  end
  
  def get_panel(panel_id)
    @panel_cache ||= {}
    
    unless @panel_cache[panel_id]
      case panel_id.to_s
      when 'AlbumList'
        panel = AlbumList.new(self, 'Album chooser',
                              2, 1, self.w - 4, self.h - 5) do |album|
          @album_model.selected = album
          self.change_state(EditState)
        end
      when 'FLNSlidingTextReader'
        panel = FLNSlidingTextReader.new(self, 'Information window',
                                         2, 1, self.w - 4, self.h - 5)
      else
        MY_LOGGER.fatal("Don't know how to create '#{panel_id}'!")
        raise "Don't know how to create '#{panel_id}'!"
      end
      
      @panel_cache[panel_id] = panel
    end
    
    @panel_cache[panel_id]
  end
  
  def change_state(new_state_klass, *args)
    MY_LOGGER.info("#{self.class.name}.change_state#before in state '#{@current_state.class.name}'")
    @previous_state = @current_state
    @current_state = new_state_klass.default

    @previous_state.exit if @previous_state
    @current_state.enter(*args) if @current_state
    MY_LOGGER.info("#{self.class.name}.change_state#after in state '#{@current_state.class.name}'")
    
    update
  end
  
  def set_active
    @control_pane.set_active!
  end
  
  def update(*args)
    @status_pane.state_label = @current_state.class.state_name
    @control_pane.prompt_label = @current_state.prompt_string
    addmessage self, :paint
    @current_state.update
  end

  def paintself(pc)
    super(pc)
    pc.move(4, 2)
    pc.addstra("::AOAIOXXYSZ:: music archive management system, v1", JTTui.aaxz_basic)
    pc.move(6, 3)
    pc.addstra("e-mail Forrest (ogd@aoaioxxysz.net) if anything weird happens.", JTTui.aaxz_basic)
  end
end

JTTui.run do |root|
  JTTColor.new('aaxz_basic', JTCur.color_white, JTCur.color_black, 0, 0).recompute
  JTTColor.new('aaxz_important', JTCur.color_white, JTCur.color_black, JTCur.attr_bold, JTCur.attr_bold).recompute
  JTTColor.new('aaxz_reversed', JTCur.color_black, JTCur.color_white, JTCur.attr_bold, JTCur.attr_bold).recompute
  JTTColor.new('color_edit_dis', JTCur.color_white, JTCur.color_black, 0, 0).recompute
  JTTColor.new('color_edit', JTCur.color_white, JTCur.color_black, JTCur.attr_bold, JTCur.attr_bold).recompute
  JTTColor.new('color_edit_hi', JTCur.color_white, JTCur.color_black, JTCur.attr_bold, JTCur.attr_bold).recompute

  processing = ProcessingApplication.new(root)
end