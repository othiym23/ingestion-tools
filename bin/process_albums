#!/usr/bin/env ruby
script_path = __FILE__
script_path = File.readlink(script_path) if File.symlink?(script_path)

$: << File.join(File.dirname(script_path), '../lib')

require 'jttui/jttui'
require 'jttui/jttuistd'
require 'yaml'
require 'logger'
require 'singleton'

require 'adaptor/euterpe_dashboard_factory' 
require 'ui/album_selection_model'
require 'ui/fln_widgets'

MY_LOGGER = Logger.new('jttui_trace.log')
#ActiveRecord::Base.logger = Logger.new('ingestion.log')

ARCHIVE_BASE = '/data/music/mp3'
PENDING_BASE = '/data/music/holding/pending'

STDOUT.sync = true
source_directory = File.expand_path(PENDING_BASE)
raise IOError.new("Path #{source_directory} does not exist!") unless File.exists?(source_directory)

at_exit { puts "\nSeeya!" }

# Hack into the guts of JTTui so I can see what it's doing, as well as
# patching a bug or two.
module JTTui
  alias_method :_send_message, :sendmessage
  def sendmessage(msg)
    log_message = "[#{msg[0].name}] received message #{msg[1]}"
    log_message << " '#{msg[2]}'" if msg[2]
    MY_LOGGER.info(log_message)
    _send_message(msg)
  end
end

class JTTWindow
  alias_method :_paint_self, :paintself
  def paintself(pc)
    MY_LOGGER.info("paintself: [#{@name}]")
    _paint_self(pc)
  end

  def visible=(v)
    if @visible ^ v
      @visible=v
      MY_LOGGER.info("FIXING JTTWindow.visible= by not exploding #{@name}'s message queue when pane " << (v ? "shown" : "hidden"))
      addmessage @parent, :paint
    end
  end
end

module Euterpe
  module Ingestion
    def self.connect_to_euterpe
      ActiveRecord::Base.establish_connection(
        :adapter  => "postgresql",
        :username => "ogd",
        :database => "euterpe-dash-dev",
        :encoding => "SQL_ASCII"
      )
    end
  end
end

class PendingStatus < FLNBorderlessPane
  def initialize(selection_model, parent, top, width)
    MY_LOGGER.info("PendingStatus initialization started")
    self.model = selection_model
    super(parent, self.class.name, width - 26, top, 26, 1, '')
    self.color = JTTui.aaxz_basic
    MY_LOGGER.info("PendingStatus initialization complete")
  end

  def paintself(pc)
    message = current_message
    pc.move(self.w - message.length, 0)
    pc.addstra(message, JTTui.aaxz_important)
  end
  
  def model=(new_model)
    @model = new_model
    @model.add_observer(self)
  end
  
  def update(*args)
    addmessage self, :paint
  end

  def current_message
    message = @model.total.to_s << ' albums'
    if @model.selected
      message << ', 1 loaded'
    elsif @model.narrowed_list && @model.narrowed_list.size > 0
      message << ', ' << @model.narrowed_list.size.to_s << ' loaded'
    end
    
    message
  end
end

class AlbumList < JTTWList
  def initialize(*args, &block)
    @totalwidth = 1
    super
    @color = JTTui.aaxz_basic
    @color_basic = JTTui.aaxz_basic
    @color_active = JTTui.aaxz_reversed
  end

  def current_album
    @album_list[@focusedentry] if @album_list
  end
  
  def album_list=(list)
    @album_list = list
    update
  end
  
  def album_string(idx)
    "#{"%03d" % (idx + 1)}. #{@album_list[idx].artist_name} - #{@album_list[idx].reconstituted_name}" if @album_list
  end
  
  def update
    @totalwidth = 1
    @album_list.each_index{ |idx|
      cw = self.list_getitemsize(idx)[0]
      @totalwidth = cw if  cw > @totalwidth
    }
    updatescrollers
  end

  def list_getitemsize(idx)
    [self.w - 1, 1]
  end
  
  def list_drawitem(pc, hilighted, focused, idx)
    super
    pc.addstr album_string(idx)
  end

  def list_gettotalwidth
    @totalwidth
  end

  def list_getlength
    (@album_list.size if @album_list) || 0
  end

  def keypress(key)
    return false if list_keyonitem(key,@focusedentry)
    callupdate=true
    case key
    when 'up', 'C-p', 'u', 'k'   then step_minus
    when 'down', 'C-n', 'd', 'j' then step_plus
    when 'home', 'M-<'           then go_start
    when 'end', 'M->'            then go_end
    when 'pgup', 'M-v'           then view_minus
    when 'pgdn', 'C-v'           then view_plus

    when 'left', 'C-b'  then @scrollx.step_minus if @scrollx
    when 'right', 'C-f' then @scrollx.step_plus  if @scrollx
    when 'M-b'          then @scrollx.view_minus if @scrollx
    when 'M-f'          then @scrollx.view_plus  if @scrollx
    when 'C-a'          then @scrollx.go_start   if @scrollx
    when 'C-e'          then @scrollx.go_end     if @scrollx
    else
      callupdate=false
      addmessage @parent, :keypress, key
    end
    scrollaction if callupdate
  end

  def action
    @block.call(@album_list[@focusedentry]) if @block
  end
end

class IllegalStateError < StandardError; end

class ControllerState
  include Singleton
  attr_writer :model, :context, :control, :status
  
  def ControllerState.default
    default_instance = instance
    default_instance.model = self.model
    default_instance.context = self.context
    default_instance.control = self.control
    default_instance.status = self.status
    
    default_instance
  end
  
  def enter
    MY_LOGGER.warn("[#{self.class.name}] abstract method 'enter' called")
  end
  
  def exit
    MY_LOGGER.warn("[#{self.class.name}] abstract method 'exit' called")
  end
  
  def update
    MY_LOGGER.warn("[#{self.class.name}] abstract method 'update' called")
  end
  
  protected
  
  def self.context
    @@context
  end
  
  def self.context=(new_context)
    @@context = new_context
  end
  
  def self.model
    @@model
  end
  
  def self.model=(new_model)
    @@model = new_model
  end
  
  def self.status
    @@status
  end
  
  def self.status=(new_status)
    @@status = new_status
  end
  
  def self.control
    @@control
  end
  
  def self.control=(new_control)
    @@control = new_control
  end
  
  def pass_the_buck(key)
    @status.message = ''
    @context.addmessage @context.parent, :keypress, key 
  end
end

class AlbumMusicBrainzEditState < ControllerState
  def AlbumMusicBrainzEditState.state_name
    'Edit album-level MusicBrainz metadata'
  end
  
  def prompt_string
    'album [i]d a[r]tist id | release [t]ype [s]tatus [c]ountry | [b]ack: '
  end
  
  def enter
    unless @model.selected
      raise IllegalStateError.new("#{self.class.name} requires an album be selected")
    end
    
    @status.message = 'WARNING: populating this data by hand isn\'t a good idea. Use the matcher.'

    unless @album_info_pane
      @album_info_pane = FLNSlidingTextReader.new(@context, 'AlbumInfoPane',
                                                  2, 1, @context.w - 4, @context.h - 5)
    else
      @album_info_pane.visible = true
    end
    
    @context.set_active
  end
  
  def exit
    @album_info_pane.visible = false
  end
  
  def update
    @album_info_pane.list = @model.selected.musicbrainz_info_formatted.split("\n")
    @album_info_pane.update
  end
  
  def dispatch(key)
    case key
    when 'i'
      get_musicbrainz_album_id
    when 'r'
      get_musicbrainz_album_artist_id
    when 't'
      get_musicbrainz_album_release_type
    when 's'
      get_musicbrainz_album_release_status
    when 'c'
      get_musicbrainz_album_release_country
    when 'b', 'Q', 'q'
      @context.change_state(EditState)
    else
      pass_the_buck(key)
    end
  end

  def get_musicbrainz_album_id
    @control.prompt_with_callback('Edit MusicBrainz album metadata', 'MusicBrainz album id: ', @model.selected.musicbrainz_album_id) do |input|
      @model.selected.musicbrainz_album_id = input if input && input != ''
      @context.update
    end
  end

  def get_musicbrainz_album_artist_id
    @control.prompt_with_callback('Edit MusicBrainz album metadata', 'MusicBrainz album artist id: ', @model.selected.musicbrainz_album_artist_id) do |input|
      @model.selected.musicbrainz_album_artist_id = input if input && input != ''
      @context.update
    end
  end

  def get_musicbrainz_album_release_type
    @status.message = 'Valid values are "album", "single", "live", "e.p."'
    @control.prompt_with_callback('Edit MusicBrainz album metadata', 'MusicBrainz album release type: ', @model.selected.musicbrainz_album_type) do |input|
      @model.selected.musicbrainz_album_type = input if input && input != ''
      @context.update
    end
  end

  def get_musicbrainz_album_release_status
    @status.message = 'Valid values are "official", "promotional", or "bootleg"'
    @control.prompt_with_callback('Edit MusicBrainz album metadata', 'MusicBrainz album release status: ', @model.selected.musicbrainz_album_status) do |input|
      @model.selected.musicbrainz_album_status = input if input && input != ''
      @context.update
    end
  end

  def get_musicbrainz_album_release_country
    @status.message = 'Use two-character ISO country codes (US, UK, JP, DE)'
    @control.prompt_with_callback('Edit MusicBrainz album metadata', 'MusicBrainz album release country: ', @model.selected.musicbrainz_album_release_country) do |input|
      @model.selected.musicbrainz_album_release_country = input.upcase if input && input != ''
      @context.update
    end
  end
end

class AlbumMetadataEditState < ControllerState
  def AlbumMetadataEditState.state_name
    'Edit album-level metadata'
  end
  
  def prompt_string
    '[n]ame [s]ort sub[t]itle [v]ersion [y]ear [g]enre [a]rtist ([S]ort) [M]usicBrainz [b]ack: '
  end
  
  def enter
    unless @model.selected
      raise IllegalStateError.new("#{self.class.name} requires an album be selected")
    end
    
    unless @album_info_pane
      @album_info_pane = FLNSlidingTextReader.new(@context, 'AlbumInfoPane',
                                                  2, 1, @context.w - 4, @context.h - 5)
    else
      @album_info_pane.visible = true
    end
    
    @context.set_active
  end
  
  def exit
    @album_info_pane.visible = false
  end
  
  def update
    @album_info_pane.list = @model.selected.display_formatted(false).split("\n")
    @album_info_pane.update
  end
  
  def dispatch(key)
    case key
    when 'n'
      get_album_name
    when 's'
      get_album_sort_order
    when 't'
      get_album_subtitle
    when 'v'
      get_album_version
    when 'a'
      get_album_artist_name
    when 'S'
      get_album_artist_sort_order
    when 'y'
      get_album_release_year
    when 'g'
      get_album_genre
    when 'b', 'Q', 'q'
      @context.change_state(EditState)
    when 'M'
      @context.change_state(AlbumMusicBrainzEditState)
    else
      pass_the_buck(key)
    end
  end

  def get_album_name
    @status.message = ''
    @control.prompt_with_callback('Edit album metadata', 'album name: ', @model.selected.name) do |input|
      @model.selected.name = input
      @context.update
    end
  end

  def get_album_sort_order
    @status.message = ''
    @control.prompt_with_callback('Edit album metadata', 'sort name: ', @model.selected.sort_order) do |input|
      @model.selected.sort_order = input
      @context.update
    end
  end

  def get_album_subtitle
    @status.message = 'Only some albums have subtitles, generally following semicolons'
    @control.prompt_with_callback('Edit album metadata', 'subtitle: ', @model.selected.subtitle) do |input|
      @model.selected.subtitle = input
      @context.update
    end
  end

  def get_album_version
    @status.message = 'Use the album version to disambiguate between independent releases'
    @control.prompt_with_callback('Edit album metadata', 'version: ', @model.selected.version_name) do |input|
      @model.selected.version_name = input
      @context.update
    end
  end

  def get_album_genre
    @status.message = 'Automatically propagate the album\'s genre out to the tracks'
    @control.prompt_with_callback('Edit album metadata', 'genre: ', @model.selected.genre) do |input|
      @model.selected.genre = input
      @context.update
    end
  end

  def get_album_artist_name
    @status.message = ''
    @control.prompt_with_callback('Edit album metadata', 'artist name: ', @model.selected.artist_name) do |input|
      @model.selected.artist_name = input
      @context.update
    end
  end

  def get_album_artist_sort_order
    @status.message = ''
    @control.prompt_with_callback('Edit album metadata', 'artist sort name: ', @model.selected.artist_sort_order) do |input|
      @model.selected.artist_sort_order = input
      @context.update
    end
  end

  def get_album_release_year
    @status.message = ''
    @control.prompt_with_callback('Edit album metadata', 'artist sort name: ', @model.selected.release_date) do |input|
      @model.selected.release_date = input
      @context.update
    end
  end
end

class YAMLState < ControllerState
  def YAMLState.state_name
    'View YAML'
  end
  
  def prompt_string
    '[e]dit metadata [h]ide YAML [b]ack: '
  end
  
  def enter
    unless @model.selected
      raise IllegalStateError.new("#{self.class.name} requires an album be selected")
    end
    
    unless @yaml_pane
      @yaml_pane = FLNSlidingTextReader.new(@context, 'YAMLPane', 2, 1,
                                            @context.w - 4, @context.h - 5)
    else
      @yaml_pane.visible = true
    end
    
    @context.set_active
  end
  
  def exit
    @yaml_pane.visible = false
  end
  
  def update
    @yaml_pane.list = YAML.dump(@model.selected).split("\n")
    @yaml_pane.update
  end
  
  def dispatch(key)
    case key
    when 'e'
      @status.message = ''
      @context.change_state(AlbumMetadataEditState)
    when 'h'
      @status.message = ''
      @context.change_state(EditState)
    when 'b', 'Q', 'q'
      @status.message = "Done with '#{@model.selected.reconstituted_name}'!"
      @model.selected = nil

      if @model.list && @model.list.size > 0
        @context.change_state(BrowseState)
      else
        @context.change_state(StartState)
      end
    else
      pass_the_buck(key)
    end
  end
end

class EditState < ControllerState
  def EditState.state_name
    'Album information'
  end
  
  def prompt_string
    'edit [a]lbum or [t]rack (get [Y]AML dump) [b]ack: '
  end
  
  def enter
    unless @model.selected
      raise IllegalStateError.new("#{self.class.name} requires an album be selected")
    end
    
    @status.message = "Displaying #{@model.selected.artist_name} - #{@model.selected.reconstituted_name}"
    unless @album_info_pane
      @album_info_pane = FLNSlidingTextReader.new(@context, 'AlbumInfoPane',
                                                  2, 1, @context.w - 4, @context.h - 5)
    else
      @album_info_pane.visible = true
    end
    
    @context.set_active
  end
  
  def exit
    @album_info_pane.visible = false
  end
  
  def update
    if @model.selected
      @album_info_pane.list = @model.selected.display_formatted(true).split("\n")
      @album_info_pane.update
    end
  end
  
  def dispatch(key)
    case key
    when 'a'
      @status.message = ''
      @context.change_state(AlbumMetadataEditState)
    when 't'
      @status.message = 'TODO: track-level editing'
    when 'Y'
      @status.message = ''
      @context.change_state(YAMLState)
    when 'b', 'Q', 'q'
      @status.message = "Done with '#{@model.selected.reconstituted_name}'!"
      @model.selected = nil
      
      if @model.list && @model.list.size > 0
        @context.change_state(BrowseState)
      else
        @context.change_state(StartState)
      end
    else
      pass_the_buck(key)
    end
  end
end

class BrowseState < ControllerState
  def BrowseState.state_name
    'Choose album'
  end
  
  def prompt_string
    if @model.list != @model.narrowed_list
      MY_LOGGER.info("original album list is [#{@model.list}] and current list is [#{@model.narrowed_list}]")
      '[n]arrow results ([c]lear narrowing) [p]rocess highlighted album [b]ack: '
    else
      '[n]arrow results [p]rocess highlighted album [b]ack: '
    end
  end
  
  def enter
    unless @model.narrowed_list
      raise IllegalStateError.new("#{self.class.name} requires a list of albums be available")
    end
    
    unless @chooser_pane
      @chooser_pane = AlbumList.new(@context, 'Album chooser',
                                    2, 1, @context.w - 4, @context.h - 5) do |album|
        @model.selected = album
        @context.change_state(EditState)
      end
    else
      @chooser_pane.visible = true
    end
  end
  
  def exit
    @chooser_pane.visible = false if @chooser_pane
  end
  
  def update
    @chooser_pane.album_list = @model.narrowed_list
    @chooser_pane.update
    JTTui.activewindow = @chooser_pane
  end
  
  def dispatch(key)
    case key
    when 'n'
      get_additional_term
    when 'c'
      @model.clear_narrowing!
      @status.message = "narrowing cleared"
    when 'p', 'e', 'C-j', 'C-m'
      @status.message = "selected #{current_album.artist_name} - #{current_album.reconstituted_name} for processing"
      @model.selected = current_album
      @context.change_state(EditState)
    when 'b', 'Q', 'q'
      @status.message = 'back to finding albums!'
      @context.change_state(StartState)
    when ('0'..'9')
      get_line_jump(key)
    else
      pass_the_buck(key)
    end
  end
  
  def current_album
    @chooser_pane.current_album
  end
  
  private
  
  def get_additional_term
    @control.prompt_with_callback('Narrow search', 'additional term: ', '') do |term|
      @model.narrow(term)
      if @model.selected
        @context.change_state(EditState)
      else
        @context.update
      end
    end
  end

  def get_line_jump(key)
    @control.prompt_with_callback('Jump to line', 'line to jump to: ', key) do |selected|
      @chooser_pane.focusedentry = selected.to_i - 1
      @context.update
    end
  end
end

class StartState < ControllerState
  def StartState.state_name
    'Top level'
  end
  
  def prompt_string
    '[f]ind albums [r]andom album [m]ost recent album [q]uit: '
  end
  
  def enter
    @model.reset_list! if @model.list
  end
  
  def dispatch(key)
    case key
    when 'f'
      get_albums
    when 'r'
      random = AlbumDao.choose_randomly
      @status.message = "#{random.artist_name} - #{random.reconstituted_name} chosen at random for processing"
      @model.selected = random
      @context.change_state(EditState)
    when 'm'
      recent = AlbumDao.choose_most_recent
      @status.message = "#{recent.artist_name} - #{recent.reconstituted_name} is the most recently added album"
      @model.selected = recent
      @context.change_state(EditState)
    when 'Q', 'q'
      @status.message = ''
      @context.addmessage nil, :quitloop, key
    else
      pass_the_buck(key)
    end
  end
  
  private
  
  def get_albums
    @status.message = ''
    @control.prompt_with_callback('Find albums', 'cached metadata search: ', '') do |query|
      @status.message = "searching Euterpe metadata cache for albums mentioning '#{query}'..."

      start_time = Time.now
      query.chomp!
      @model.narrow(query)
      finish_time = Time.now

      time = finish_time - start_time

      found_albums = @model.list || []
      case found_albums.size
      when 0
        @status.message = "no results (query ran in #{time.to_f} seconds)"
      when 1
        @status.message = "single album found in #{time.to_f} seconds"
        @model.selected = found_albums.first
        @context.change_state(EditState)
      else
        @status.message = "#{found_albums.size} records found in #{time.to_f} seconds"
        @context.change_state(BrowseState)
      end
      MY_LOGGER.info("SearchMode.find_albums found [#{@model.list}]")
    end
  end
end

class StatusPane < FLNBorderlessPane
  def initialize(model, parent, left, top, width)
    MY_LOGGER.info("StatusPane initialization started")
    super(parent, self.class.name, left, top, width, 3, '')
    @color = JTTui.aaxz_basic

    @state_label = JTTWLabel.new(self, 'state_label', 0, 0, self.w, 1, '')
    @state_label.color = JTTui.aaxz_basic
    
    @status_line = FLNImmediateLabel.new(self, 'status_line', 0, self.h - 1, self.w - 26, 1, '')
    @pending = PendingStatus.new(model, self, self.h - 1, self.w)
    MY_LOGGER.info("StatusPane initialization complete")
  end

  def state_label=(mode_name)
    @state_label.caption = mode_name
  end
  
  def message=(value)
    MY_LOGGER.info("#{self.class.name} message '#{value}'")
    @status = value || ''
    @status_line.caption = @status
  end
end

class ControlPane
  def initialize(parent, top, width)
    MY_LOGGER.info("ControlPane initialization started")
    @parent = parent

    @prompt_label = JTTWLabel.new(parent, 'prompt_label', 0, top, width, 1, 'LOADING')
    @prompt_label.color = JTTui.aaxz_basic
    MY_LOGGER.info("ControlPane initialization complete")
  end
  
  def prompt_label=(value)
    @prompt_label.caption = value
  end
  
  def prompt_with_callback(state_label, prompt_string, initial_value, &block)
    @parent.state_label = state_label
    @prompt_label.caption = prompt_string

    @prompt_field = FLNButtonlessEditline.new(@parent, 'prompt_field',
                                              prompt_string.size - 1, @parent.h - 2, 
                                              @parent.w - (prompt_string.size + 2), 1, '', true)
    @prompt_field.get_finished(initial_value || '', &block)
    JTTui.activewindow = @prompt_field
    
    @parent.addmessage @parent, :paint
  end
  
  def set_active!
    JTTui.activewindow = @prompt_label
  end
end

class ProcessingApplication < FLNBorderlessPane
  attr_reader :prompt_label
  
  def initialize(parent)
    MY_LOGGER.info("ProcessingApplication initialization started")
    self.visible = false
    
    super(parent, self.class.name, 0, 0, parent.w, parent.h, '')
    @color = JTTui.aaxz_basic
    
    @album_model = AlbumSelectionModel.new
    
    @status_pane = StatusPane.new(@album_model, self, 0, self.h - 3, self.w)
    @album_model.status = @status_pane
    
    @control_pane = ControlPane.new(@status_pane, @status_pane.h - 2, @status_pane.w)
    
    @status_pane.message = "Connecting to metadata cache..."
    Euterpe::Ingestion::connect_to_euterpe
    @status_pane.message = 'Connected to metadata cache'
    
    ControllerState.model = @album_model
    ControllerState.context = self
    ControllerState.control = @control_pane
    ControllerState.status = @status_pane

    @current_state = StartState.default
    
    @album_model.add_observer(self)
    @album_model.total = Euterpe::Dashboard::Album.count
    MY_LOGGER.info("#{@album_model.total} albums loaded")
    
    self.visible = true
    MY_LOGGER.info("ProcessingApplication initialization complete")
  end
  
  def keypress(key)
    @current_state.dispatch(key)
  end
  
  def change_state(new_state_klass)
    MY_LOGGER.info("#{self.class.name}.change_state#before in state '#{@current_state.class.name}'")
    @previous_state = @current_state
    @current_state = new_state_klass.default

    @previous_state.exit if @previous_state
    @current_state.enter if @current_state
    MY_LOGGER.info("#{self.class.name}.change_state#after in state '#{@current_state.class.name}'")
    
    update
  end
  
  def set_active
    @control_pane.set_active!
  end
  
  def update(*args)
    @status_pane.state_label = @current_state.class.state_name
    @control_pane.prompt_label = @current_state.prompt_string
    addmessage self, :paint
    @current_state.update
  end

  def paintself(pc)
    super(pc)
    pc.move(4, 2)
    pc.addstra("::AOAIOXXYSZ:: music archive management system, v1", JTTui.aaxz_basic)
    pc.move(6, 3)
    pc.addstra("e-mail Forrest (ogd@aoaioxxysz.net) if anything weird happens.", JTTui.aaxz_basic)
  end
end

JTTui.run do |root|
  JTTColor.new('aaxz_basic', JTCur.color_white, JTCur.color_black, 0, 0).recompute
  JTTColor.new('aaxz_important', JTCur.color_white, JTCur.color_black, JTCur.attr_bold, JTCur.attr_bold).recompute
  JTTColor.new('aaxz_reversed', JTCur.color_black, JTCur.color_white, JTCur.attr_bold, JTCur.attr_bold).recompute
  JTTColor.new('color_edit_dis', JTCur.color_white, JTCur.color_black, 0, 0).recompute
  JTTColor.new('color_edit', JTCur.color_white, JTCur.color_black, JTCur.attr_bold, JTCur.attr_bold).recompute
  JTTColor.new('color_edit_hi', JTCur.color_white, JTCur.color_black, JTCur.attr_bold, JTCur.attr_bold).recompute

  processing = ProcessingApplication.new(root)
end